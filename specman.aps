module Specman begin
        type Symbol_;
        type Boolean;

        phylum Module;

        phylum Statement;
        phylum Statements = LIST[Statement];

        phylum StructMember;
        phylum StructMembers = LIST[StructMember];

        phylum Expression;
        phylum Expressions = LIST[Expression];

        constructor module_(stmts: Statements) : Module;

        constructor package(pkg_name: Symbol_) : Statement;
        constructor unit(unit_name: Symbol_; members: StructMembers) : Statement;
        constructor struct_(struct_name: Symbol_; members: StructMembers) : Statement;
        constructor extend_like(uos_name: Symbol_; base_uos_name: Symbol_; members: StructMembers) : Statement;
        constructor extend_when(uos_name: Symbol_; members: StructMembers) : Statement;
        constructor type_(type_id: Symbol_; type_expr: Expression)  : Statement;

        constructor id_expr(id: Symbol_) : Expression;
        
        constructor enum_type_expr(enum_list_expr: Expressions) : Expression;
        constructor enum_list_item(id: Symbol_; expr: Expression) : Expression;
        
        constructor bitwise_not_expr(e: Expression) : Expression;
        constructor bitwise_and_expr(e1: Expression; e2: Expression) : Expression;
        constructor bitwise_or_expr(e1: Expression; e2: Expression) : Expression;
        constructor bitwise_xor_expr(e1: Expression; e2: Expression) : Expression;
        constructor shift_left_expr(e1: Expression; e2: Expression) : Expression;
        constructor right_left_expr(e1: Expression; e2: Expression) : Expression;
        
        constructor logical_not_expr(e: Expression) : Expression;
        constructor logical_and_expr(e1: Expression; e2: Expression) : Expression;
        constructor logical_or_expr(e1: Expression; e2: Expression) : Expression;
        constructor implication_expr(e1: Expression; e2: Expression) : Expression;

        constructor unary_positive_expr(e: Expression) : Expression;
        constructor unary_negative_expr(e: Expression) : Expression;

        constructor binary_add_expr(e1: Expression; e2: Expression) : Expression;
        constructor binary_sub_expr(e1: Expression; e2: Expression) : Expression;
        constructor binary_mul_expr(e1: Expression; e2: Expression) : Expression;
        constructor binary_remainder_expr(e1: Expression; e2: Expression) : Expression;

        constructor less_then_expr(e1: Expression; e2: Expression) : Expression;
        constructor greater_then_expr(e1: Expression; e2: Expression) : Expression;
        constructor less_then_or_equal_expr(e1: Expression; e2: Expression) : Expression;
        constructor greater_then_or_equal_expr(e1: Expression; e2: Expression) : Expression;
        constructor equality_expr(e1: Expression; e2: Expression) : Expression;
        constructor non_equality_expr(e1: Expression; e2: Expression) : Expression;
        constructor hdl_equality_expr(e1: Expression; e2: Expression) : Expression;
        constructor hdl_non_equality_expr(e1: Expression; e2: Expression) : Expression;
        constructor str_match_expr(str_expr: Expression; pattern_expr: Expression) : Expression;
        constructor str_does_not_match_expr(str_expr: Expression; pattern_expr: Expression) : Expression;

        constructor in_expr(exp: Expression; inside: Expression) : Expression;
        constructor list_indexing_expr(list_exp: Expression; idx_expr: Expression) : Expression;
        constructor list_slicing_expr(list_exp: Expression; high_expr: Expression; low_expr: Expression; slice_expr: Expression) : Expression;
        constructor list_splicing_expr(list_exp: Expression; low_expr: Expression; high_expr: Expression) : Expression;
        constructor list_concat_expr(list_concat_items: Expressions) : Expression;
        constructor bit_concat_expr(bit_concat_items: Expressions) : Expression;

        constructor str_expr(str: Symbol_) : Expression;
        constructor no_expr() : Expression;
end;