#ifndef DRIVER_H
#define DRIVER_H

#include <vector>

#include "specman-tree.hpp"
#include "scanner.hpp"

// autogenerated by Bison, don't panic
// if your IDE can't resolve it - call make first
#include "parser.hpp"
#include "location.hh"

// symbol tables
#include "strtab.hpp"

# ifdef YYLLOC_DEFAULT
 #undef YYLLOC_DEFAULT
# endif

/*
* Basically the same default location update macro generated 
* by Bison itself, but updates the driver's location tracker 
* at the end of it
*/
#  define YYLLOC_DEFAULT(Current, Rhs, N)                               \
    do  {                                                               \
      if (N)                                                            \
        {                                                               \
          (Current).begin  = YYRHSLOC (Rhs, 1).begin;                   \
          (Current).end    = YYRHSLOC (Rhs, N).end;                     \
        }                                                               \
      else                                                              \
        {                                                               \
          (Current).begin = (Current).end = YYRHSLOC (Rhs, 0).end;      \
        }                                                               \
        driver.cur_location = (Current);/* update the driver location*/ \
    }                                                                   \
    while (/*CONSTCOND*/ false)


namespace yy {

    /**
     * This class is the interface for our scanner/lexer. The end user
     * is expected to use this. It drives scanner/lexer, keeps
     * parsed AST and generally is a good place to store additional
     * context data. Both parser and lexer have access to it via internal 
     * references.
     */
    class driver
    {
        // parser current reduced symbol type location
        static yy::location cur_location;
    public:
        driver();
        
        /**
         * Run parser. Results are stored inside.
         * \returns 0 on success, 1 on failure
         */
        int parse();
        
        /**
         * Clear AST
         */
        void clear();
        
        /**
         * Print AST
         */
        std::string str() const;
        
        /**
         * Switch scanner input stream. Default is standard input (std::cin).
         * It will also reset AST.
         */
        void switchInputStream(std::istream *is);
        
        /**
         * dump table symbols
         * 
         */
        auto dump_symbols() const -> void;

        /**
         * assign the root of an ast
         * 
         */
        auto set_root(elex::Module) -> void;

        /**
         * This is needed so that Scanner and Parser can call some
         * methods that we want to keep hidden from the end user.
         */
        friend class parser;
        friend class scanner;
        
        /**
         * Returns a handler to the scanner
         */
        yy::scanner& getScanner() { return m_scanner; }
        
        /**
         * Returns the location of the currently reduced symbol
         * 
         * This is tracked by the parser, updated by YYLLOC_DEFAULT action
         * and consumed by each tree_node at construction time
         * 
         * DO NOT confuse this with the location tracked by the lexer
         * which is consumed by the parser for error messaging
         */
        static auto parse_location() -> yy::location { return cur_location; }
    private:
        scanner m_scanner;
        parser m_parser;

        // symbol table for strings, ids & integers
        // will be accessed directly by the scanner
        // flex rules to add symbols
        elex::SymTable strtable;
        elex::SymTable inttable;
        elex::SymTable idtable;

        // parser results
        elex::Module ast_root;

    };

}

#endif // DRIVER_H
